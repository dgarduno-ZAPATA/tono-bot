import os
import asyncio
import httpx
import json
import logging
import re
from datetime import datetime, timedelta

import pytz

logger = logging.getLogger(__name__)

# Meses en espa√±ol para nombres de grupos en Monday
MESES_ES = {
    1: "ENERO", 2: "FEBRERO", 3: "MARZO", 4: "ABRIL",
    5: "MAYO", 6: "JUNIO", 7: "JULIO", 8: "AGOSTO",
    9: "SEPTIEMBRE", 10: "OCTUBRE", 11: "NOVIEMBRE", 12: "DICIEMBRE"
}

# ============================================================
# V2: STAGE HIERARCHY (solo avanza, nunca retrocede)
# ============================================================
STAGE_HIERARCHY = {
    "1er Contacto": 1,
    "Intenci√≥n": 2,
    "Cotizaci√≥n": 3,
    "Cita Programada": 4,
}

# Estados terminales: si el lead est√° en uno de estos, se crea nuevo item
TERMINAL_STAGES = {"Venta Cerrada", "Venta Caida", "Sin Interes"}

# ============================================================
# V2: VEHICLE SYNONYMS ‚Üí Monday dropdown labels
# ============================================================
VEHICLE_DROPDOWN_MAP = {
    "Tunland E5": ["e5", "tunland", "tunland e5"],
    "ESTA 6x4 11.8": ["esta 11.8", "6x4 11.8", "esta"],
    "ESTA 6x4 X13": ["esta x13", "6x4 x13"],
    "Miler": ["miler", "miller"],
    "Toano Panel": ["toano", "panel", "toano panel"],
    "Tunland G7": ["g7", "tunland g7"],
    "Tunland G9": ["g9", "tunland g9"],
}


def _get_current_month_group_name() -> str:
    """Retorna el nombre del grupo del mes actual: 'FEBRERO 2026'"""
    try:
        tz = pytz.timezone("America/Mexico_City")
        now = datetime.now(tz)
    except Exception:
        now = datetime.now()

    mes = MESES_ES.get(now.month, "")
    return f"{mes} {now.year}"


def resolve_vehicle_to_dropdown(interest: str) -> str:
    """
    Dado un inter√©s detectado por el bot (ej. 'Foton Tunland G9 2025'),
    devuelve el label EXACTO del dropdown de Monday (ej. 'Tunland G9').
    Retorna '' si no hay match.
    """
    if not interest:
        return ""

    interest_lower = interest.lower().replace("foton", "").replace("diesel", "").replace("4x4", "").strip()

    best_label = ""
    best_score = 0

    for label, synonyms in VEHICLE_DROPDOWN_MAP.items():
        score = 0
        for syn in synonyms:
            if syn in interest_lower:
                score += len(syn)  # Longer match = higher score
        if score > best_score:
            best_score = score
            best_label = label

    return best_label


def resolve_payment_to_label(payment: str) -> str:
    """
    Mapea el pago extra√≠do por el bot al label EXACTO de Monday.
    'Contado' ‚Üí 'De Contado', 'Cr√©dito' ‚Üí 'Financiamiento', default ‚Üí 'Por definir'
    """
    if not payment:
        return "Por definir"

    p = payment.lower().strip()
    if p in ("contado", "de contado", "cash"):
        return "De Contado"
    if p in ("cr√©dito", "credito", "financiamiento", "financiaci√≥n"):
        return "Financiamiento"
    return "Por definir"


def resolve_appointment_to_iso(appointment_text: str) -> dict:
    """
    Convierte texto de cita (ej. 'Viernes 10:00 AM') a formato ISO para Monday date column.
    Retorna dict con 'date' y opcionalmente 'time', o {} si no se puede parsear.
    Timezone: America/Mexico_City
    """
    if not appointment_text:
        return {}

    try:
        tz = pytz.timezone("America/Mexico_City")
        now = datetime.now(tz)
    except Exception:
        now = datetime.now()

    text = appointment_text.strip().lower()
    target_date = None
    target_time = None

    # --- Parse day ---
    dias_map = {
        "lunes": 0, "martes": 1, "mi√©rcoles": 2, "miercoles": 2,
        "jueves": 3, "viernes": 4, "s√°bado": 5, "sabado": 5, "domingo": 6,
    }

    if "ma√±ana" in text:
        target_date = now.date() + timedelta(days=1)
    elif "pasado ma√±ana" in text:
        target_date = now.date() + timedelta(days=2)
    elif "pr√≥xima semana" in text or "proxima semana" in text:
        # Next Monday
        days_until_monday = (7 - now.weekday()) % 7
        if days_until_monday == 0:
            days_until_monday = 7
        target_date = now.date() + timedelta(days=days_until_monday)
    else:
        for dia_name, dia_num in dias_map.items():
            if dia_name in text:
                days_ahead = (dia_num - now.weekday()) % 7
                if days_ahead == 0:
                    days_ahead = 7  # Next week if same day
                target_date = now.date() + timedelta(days=days_ahead)
                break

    # Try explicit date: "10 de marzo", "marzo 10", etc.
    if not target_date:
        meses_map = {
            "enero": 1, "febrero": 2, "marzo": 3, "abril": 4,
            "mayo": 5, "junio": 6, "julio": 7, "agosto": 8,
            "septiembre": 9, "octubre": 10, "noviembre": 11, "diciembre": 12,
        }
        m = re.search(r"(\d{1,2})\s+de\s+(\w+)", text)
        if m:
            day_num = int(m.group(1))
            month_name = m.group(2).lower()
            month_num = meses_map.get(month_name)
            if month_num and 1 <= day_num <= 31:
                year = now.year
                if month_num < now.month or (month_num == now.month and day_num < now.day):
                    year += 1
                try:
                    target_date = datetime(year, month_num, day_num).date()
                except ValueError:
                    pass

    # If still no date, default to today (appointment mentioned without day)
    if not target_date:
        target_date = now.date()

    # --- Parse time ---
    # "medio d√≠a" / "mediod√≠a"
    if "medio dia" in text or "mediod√≠a" in text or "medio d√≠a" in text:
        target_time = "12:00:00"

    if not target_time:
        m = re.search(r"(\d{1,2})\s*y\s*media", text)
        if m:
            h = int(m.group(1))
            if 1 <= h <= 12:
                target_time = f"{h:02d}:30:00"

    if not target_time:
        m = re.search(r"(\d{1,2})\s*:\s*(\d{2})\s*(am|pm)?", text, re.IGNORECASE)
        if m:
            h = int(m.group(1))
            mm = int(m.group(2))
            meridiem = (m.group(3) or "").lower()
            if meridiem == "pm" and h < 12:
                h += 12
            elif meridiem == "am" and h == 12:
                h = 0
            if 0 <= h <= 23 and 0 <= mm <= 59:
                target_time = f"{h:02d}:{mm:02d}:00"

    if not target_time:
        m = re.search(r"(\d{1,2})\s*(am|pm)", text, re.IGNORECASE)
        if m:
            h = int(m.group(1))
            meridiem = m.group(2).lower()
            if 1 <= h <= 12:
                hh = h % 12
                if meridiem == "pm":
                    hh += 12
                target_time = f"{hh:02d}:00:00"

    if not target_time:
        if "tarde" in text:
            target_time = "15:00:00"
        elif "ma√±ana" in text and "por la" in text:
            target_time = "10:00:00"

    result = {}
    if target_date:
        result["date"] = target_date.isoformat()
    if target_time:
        result["time"] = target_time
    return result


class MondayService:
    def __init__(self):
        self.api_key = os.getenv("MONDAY_API_KEY")
        self.board_id = os.getenv("MONDAY_BOARD_ID")
        self.api_url = "https://api.monday.com/v2"

        # --- V1 Column IDs ---
        self.phone_dedupe_col_id = os.getenv("MONDAY_DEDUPE_COLUMN_ID")
        self.last_msg_id_col_id = os.getenv("MONDAY_LAST_MSG_ID_COLUMN_ID")
        self.phone_real_col_id = os.getenv("MONDAY_PHONE_COLUMN_ID")
        self.stage_col_id = os.getenv("MONDAY_STAGE_COLUMN_ID")

        # --- V2 NEW Column IDs ---
        self.vehicle_col_id = os.getenv("MONDAY_VEHICLE_COLUMN_ID")
        self.payment_col_id = os.getenv("MONDAY_PAYMENT_COLUMN_ID")
        self.appointment_col_id = os.getenv("MONDAY_APPOINTMENT_COLUMN_ID")
        self.cmv_col_id = os.getenv("MONDAY_CMV_COLUMN_ID")

        # Log config
        if self.stage_col_id:
            logger.info(f"‚úÖ Monday Stage Column: {self.stage_col_id}")
        else:
            logger.warning("‚ö†Ô∏è MONDAY_STAGE_COLUMN_ID no configurada")

        v2_cols = {
            "vehicle": self.vehicle_col_id,
            "payment": self.payment_col_id,
            "appointment": self.appointment_col_id,
        }
        configured = {k: v for k, v in v2_cols.items() if v}
        if configured:
            logger.info(f"‚úÖ V2 columns: {configured}")
        else:
            logger.warning("‚ö†Ô∏è No V2 column IDs configured (vehicle/payment/appointment)")

    def _sanitize_phone(self, phone: str) -> str:
        if not phone:
            return ""
        return re.sub(r'\D', '', str(phone))

    async def _graphql(self, query: str, variables: dict):
        if not self.api_key:
            raise RuntimeError("MONDAY_API_KEY no configurada")

        headers = {"Authorization": self.api_key, "Content-Type": "application/json"}
        payload = {"query": query, "variables": variables}

        _MAX_RETRIES = 3
        for _attempt in range(_MAX_RETRIES):
            try:
                async with httpx.AsyncClient(timeout=25.0) as client:
                    resp = await client.post(self.api_url, json=payload, headers=headers)

                if resp.status_code >= 500 and _attempt < _MAX_RETRIES - 1:
                    backoff = 2 ** (_attempt + 1)
                    logger.warning(f"‚ö†Ô∏è Monday 5xx retry {_attempt + 1}/{_MAX_RETRIES} tras {backoff}s: {resp.status_code}")
                    await asyncio.sleep(backoff)
                    continue

                data = resp.json()
                if "errors" in data:
                    logger.error(f"Monday API Error: {data['errors']}")
                return data

            except (httpx.TimeoutException, httpx.RequestError) as e:
                if _attempt < _MAX_RETRIES - 1:
                    backoff = 2 ** (_attempt + 1)
                    logger.warning(f"‚ö†Ô∏è Monday retry {_attempt + 1}/{_MAX_RETRIES} tras {backoff}s: {e}")
                    await asyncio.sleep(backoff)
                else:
                    raise

    async def _find_item_by_phone(self, phone_limpio: str):
        """
        V2: Busca item por tel√©fono y retorna dict con id, name, y stage actual.
        Retorna el item M√ÅS RECIENTE (√∫ltimo creado) si hay m√∫ltiples.
        """
        if not phone_limpio or not self.phone_dedupe_col_id:
            return None

        query = """
        query ($board_id: ID!, $col_id: String!, $val: String!) {
          items_page_by_column_values(
            limit: 10,
            board_id: $board_id,
            columns: [{column_id: $col_id, column_values: [$val]}]
          ) {
            items {
              id
              name
              column_values {
                id
                text
                value
              }
            }
          }
        }
        """
        variables = {
            "board_id": int(self.board_id),
            "col_id": self.phone_dedupe_col_id,
            "val": phone_limpio
        }

        data = await self._graphql(query, variables)
        items = data.get("data", {}).get("items_page_by_column_values", {}).get("items", [])

        if not items:
            return None

        # Find the most recent item (highest ID = most recently created)
        best_item = max(items, key=lambda x: int(x.get("id", 0)))

        # Extract current stage from column_values
        current_stage = ""
        if self.stage_col_id:
            for col in best_item.get("column_values", []):
                if col.get("id") == self.stage_col_id:
                    current_stage = (col.get("text") or "").strip()
                    break

        return {
            "id": best_item["id"],
            "name": best_item.get("name", ""),
            "current_stage": current_stage,
        }

    async def _get_group_id_by_name(self, group_name: str):
        if not group_name:
            return None

        query = """
        query ($board_id: ID!) {
          boards(ids: [$board_id]) {
            groups {
              id
              title
            }
          }
        }
        """
        variables = {"board_id": int(self.board_id)}

        data = await self._graphql(query, variables)
        boards = data.get("data", {}).get("boards", [])

        if not boards:
            return None

        groups = boards[0].get("groups", [])

        for group in groups:
            if group.get("title", "").upper() == group_name.upper():
                logger.info(f"‚úÖ Grupo encontrado: '{group['title']}' (ID: {group['id']})")
                return group["id"]

        logger.warning(f"‚ö†Ô∏è Grupo '{group_name}' no encontrado en el tablero")
        return None

    def _should_advance_stage(self, current_stage: str, candidate_stage: str) -> bool:
        """V2: Solo avanza el embudo, nunca retrocede."""
        current_rank = STAGE_HIERARCHY.get(current_stage, 0)
        candidate_rank = STAGE_HIERARCHY.get(candidate_stage, 0)
        return candidate_rank > current_rank

    def _build_column_values(self, lead_data: dict, stage: str = None, is_new: bool = False,
                             current_stage: str = "") -> dict:
        """
        V2: Construye el dict de column_values para Monday GraphQL.
        Respeta la jerarqu√≠a del embudo (solo avanza).
        """
        col_vals = {}

        # Dedupe phone (always)
        phone_limpio = self._sanitize_phone(str(lead_data.get("telefono", "")))
        if self.phone_dedupe_col_id and phone_limpio:
            col_vals[self.phone_dedupe_col_id] = phone_limpio

        # Message ID tracking
        msg_id = str(lead_data.get("external_id", "")).strip()
        if self.last_msg_id_col_id and msg_id:
            col_vals[self.last_msg_id_col_id] = msg_id

        # Real phone column
        if self.phone_real_col_id and phone_limpio:
            col_vals[self.phone_real_col_id] = {"phone": phone_limpio, "countryShortName": "MX"}

        # --- V2: Stage (Embudo) with direction enforcement ---
        if stage and self.stage_col_id:
            if is_new:
                col_vals[self.stage_col_id] = {"label": stage}
                logger.info(f"üìä Nuevo item ‚Üí Embudo: {stage}")
            elif stage == "Sin Interes":
                # Sin Interes overrides any stage
                col_vals[self.stage_col_id] = {"label": stage}
                logger.info(f"üìä Sin Interes ‚Üí Embudo: {stage}")
            elif self._should_advance_stage(current_stage, stage):
                col_vals[self.stage_col_id] = {"label": stage}
                logger.info(f"üìä Embudo avanza: {current_stage} ‚Üí {stage}")
            else:
                logger.info(f"üìä Embudo NO retrocede: {current_stage} ‚Üí {stage} (ignorado)")

        # --- V2: Vehicle (Dropdown) ---
        if self.vehicle_col_id:
            interest = lead_data.get("interes") or ""
            vehicle_label = resolve_vehicle_to_dropdown(interest)
            if vehicle_label:
                col_vals[self.vehicle_col_id] = {"labels": [vehicle_label]}

        # --- V2: Payment (Status) ---
        if self.payment_col_id:
            payment_raw = lead_data.get("pago") or ""
            payment_label = resolve_payment_to_label(payment_raw)
            if is_new or payment_label != "Por definir":
                col_vals[self.payment_col_id] = {"label": payment_label}

        # --- V2: Appointment (Date) ---
        if self.appointment_col_id:
            appointment_text = lead_data.get("cita") or ""
            appointment_iso = lead_data.get("cita_iso") or resolve_appointment_to_iso(appointment_text)
            if appointment_iso and appointment_iso.get("date"):
                col_vals[self.appointment_col_id] = appointment_iso

        return col_vals

    async def create_or_update_lead(self, lead_data: dict, stage: str = None, add_note: str = None):
        """
        V2: Crea o actualiza un lead en Monday.com.

        Reglas V2:
        - Labels: 1er Contacto, Intenci√≥n, Cotizaci√≥n, Cita Programada, Sin Interes
        - Terminal states (Venta Cerrada, Venta Caida, Sin Interes): crear nuevo item
        - Embudo solo avanza, nunca retrocede
        - Veh√≠culo, Pago, Agenda Citas ‚Üí columnas dedicadas
        """
        raw_phone = str(lead_data.get("telefono", ""))
        phone_limpio = self._sanitize_phone(raw_phone)
        nombre = str(lead_data.get("nombre", "")).strip() or "Lead sin nombre"
        msg_id = str(lead_data.get("external_id", "")).strip()

        if not phone_limpio:
            logger.warning("‚ö†Ô∏è Lead sin tel√©fono, no se puede procesar.")
            return None

        # 1. BUSCAR DUPLICADO
        existing = await self._find_item_by_phone(phone_limpio)

        # 2. DECIDIR: CREAR o ACTUALIZAR
        is_new = False
        item_id = None
        current_stage = ""

        if existing:
            current_stage = existing.get("current_stage", "")
            item_id = existing["id"]

            # V2: Terminal state ‚Üí crear nuevo item (nuevo ciclo)
            if current_stage in TERMINAL_STAGES:
                logger.info(
                    f"üîÑ Lead en estado terminal '{current_stage}' ‚Üí creando nuevo ciclo para {phone_limpio}"
                )
                is_new = True
                item_id = None
                current_stage = ""
            else:
                is_new = False
        else:
            is_new = True

        # 3. CONSTRUIR COLUMN VALUES
        effective_stage = stage or ("1er Contacto" if is_new else "")
        col_vals = self._build_column_values(
            lead_data,
            stage=effective_stage,
            is_new=is_new,
            current_stage=current_stage,
        )

        # 4. CREAR O ACTUALIZAR
        if is_new:
            # --- CREAR NUEVO ---
            month_group_name = _get_current_month_group_name()
            group_id = await self._get_group_id_by_name(month_group_name)

            item_name_display = f"{nombre} | {phone_limpio}"

            if group_id:
                logger.info(f"üÜï Creando lead [{effective_stage}] en grupo '{month_group_name}': {phone_limpio}")
                query_create = """
                mutation ($board_id: ID!, $group_id: String!, $name: String!, $vals: JSON!) {
                    create_item (board_id: $board_id, group_id: $group_id, item_name: $name, column_values: $vals) { id }
                }
                """
            else:
                logger.info(f"üÜï Creando lead [{effective_stage}] (sin grupo): {phone_limpio}")
                query_create = """
                mutation ($board_id: ID!, $name: String!, $vals: JSON!) {
                    create_item (board_id: $board_id, item_name: $name, column_values: $vals) { id }
                }
                """

            vars_create = {
                "board_id": int(self.board_id),
                "name": item_name_display,
                "vals": json.dumps(col_vals)
            }
            if group_id:
                vars_create["group_id"] = group_id

            res = await self._graphql(query_create, vars_create)
            item_id = res.get("data", {}).get("create_item", {}).get("id")

        else:
            # --- ACTUALIZAR EXISTENTE ---
            logger.info(f"‚ôªÔ∏è Actualizando lead [{effective_stage or 'datos'}] (ID: {item_id})")

            if col_vals:
                query_update = """
                mutation ($item_id: ID!, $board_id: ID!, $vals: JSON!) {
                    change_multiple_column_values (item_id: $item_id, board_id: $board_id, column_values: $vals) { id }
                }
                """
                vars_update = {
                    "item_id": int(item_id),
                    "board_id": int(self.board_id),
                    "vals": json.dumps(col_vals)
                }
                await self._graphql(query_update, vars_update)

            # Update item name if we have a real name
            if nombre and nombre != "Lead sin nombre":
                new_item_name = f"{nombre} | {phone_limpio}"
                query_rename = """
                mutation ($board_id: ID!, $item_id: ID!, $col_id: String!, $value: String!) {
                    change_simple_column_value(board_id: $board_id, item_id: $item_id, column_id: $col_id, value: $value) { id }
                }
                """
                vars_rename = {
                    "board_id": int(self.board_id),
                    "item_id": int(item_id),
                    "col_id": "name",
                    "value": new_item_name,
                }
                try:
                    await self._graphql(query_rename, vars_rename)
                    logger.info(f"‚úÖ Nombre actualizado en Monday: '{new_item_name}'")
                except Exception as e:
                    logger.error(f"‚ö†Ô∏è Error actualizando nombre en Monday: {e}")

        # 5. AGREGAR NOTA
        if item_id and (is_new or add_note):
            if is_new:
                detalles = (
                    f"üìä ETAPA: {effective_stage}\n"
                    f"üë§ Nombre: {nombre}\n"
                    f"üìû Tel: {phone_limpio}\n"
                    f"üìù Inter√©s: {lead_data.get('interes', 'N/A')}\n"
                )
                if lead_data.get('cita'):
                    cita_iso = lead_data.get('cita_iso') or resolve_appointment_to_iso(lead_data.get('cita', ''))
                    if cita_iso.get('date'):
                        detalles += f"üìÖ Cita: {cita_iso['date']}"
                        if cita_iso.get('time'):
                            detalles += f" {cita_iso['time']}"
                        detalles += "\n"
                    else:
                        detalles += f"üìÖ Cita: {lead_data.get('cita')}\n"
                pago_label = resolve_payment_to_label(lead_data.get('pago', ''))
                detalles += f"üí∞ Pago: {pago_label}\n"
            else:
                detalles = add_note or f"üìä Actualizado a etapa: {effective_stage}"

            query_note = """
            mutation ($item_id: ID!, $body: String!) {
                create_update (item_id: $item_id, body: $body) { id }
            }
            """
            await self._graphql(query_note, {"item_id": int(item_id), "body": detalles})

        return item_id

    # Backwards compatibility
    async def create_lead(self, lead_data: dict):
        return await self.create_or_update_lead(lead_data, stage="Cita Programada")


# Instancia lista para usar
monday_service = MondayService()
